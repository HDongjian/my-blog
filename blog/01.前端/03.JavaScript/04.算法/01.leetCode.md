---
title: leetCode
date: 2021-07-25 19:53:10
permalink: /pages/201fff/
categories: 算法
tags:
  -
---

## 两数之和

- 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。

```js
var twoSum = function(nums, target) {
  let map = {}
  let result = []
  for (var i = 0; i < nums.length; i++) {
    let ele = nums[i]
    if (Object.hasOwnProperty.call(map, ele)) {
      result[0] = i
      result[1] = map[nums[i]]
      return result
    }
    map[[target - ele]] = i
  }
}
```

## 两数相加

- 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
- 请你将两个数相加，并以相同形式返回一个表示和的链表。
- 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```js
  function listData(data) {
    let index = 0
    let result = new ListNode(data[index]);
    while (index<data.length-1) {
      index++
      result = new ListNode(data[index],result)
    }
    return result
  }

  let l1 = [2, 4, 3],
    l2 = [5, 6, 4]


  /**
   * Definition for singly-linked list.
   * function ListNode(val, next) {
   *     this.val = (val===undefined ? 0 : val)
   *     this.next = (next===undefined ? null : next)
   * }
   */
  /**
   * @param {ListNode} l1
   * @param {ListNode} l2
   * @return {ListNode}
   */
  l1 = listData(l1)
  l2 = listData(l2)
  console.log(l1)

  function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val)
    this.next = (next === undefined ? null : next)
  }
  var addTwoNumbers = function (l1, l2) {
    // 创建临时的链表
    let resNode = new ListNode(0);
    // 记录好相关的临时链表信息
    let res = resNode;
    // 记录是否进行进位运算
    let flag = 0;
    //当l1不为空或l2不为空或不需要进位时
    while (l1 || l2 || flag) {
      // 记录其相关的值
      let val1 = l1 ? l1.val : 0;
      let val2 = l2 ? l2.val : 0;
      console.log(val1,val2)
      let sum = val1 + val2 + flag;
      //判断是否需要进位
      flag = sum >= 10 ? 1 : 0;
      //链表所存储的元素只能为余数
      sum = sum % 10;
      //当相关的链表不为空时，则链表一次向下遍历
      if (l1) {
        l1 = l1.next;
      }
      if (l2) {
        l2 = l2.next;
      }
      //向临时创建的链表追加元素
      resNode.next = new ListNode(sum);
      resNode = resNode.next;
    }
    return res.next;
  };
```

## 无重复字符的最长子串

- 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

- 输入: s = "abcabcbb"
- 输出: 3 
- 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

```js
  var lengthOfLongestSubstring = function (s) {
    let max = 0,
      arr = []
    for (let i = 0; i < s.length; i++) {
      let index = arr.indexOf(s[i])
      if (index >= 0) {
        arr.splice(0, index + 1)
      }
      arr.push(s.charAt(i))
      max = Math.max(arr.length, max)
    }
    return max
  };
```

### 解题思路

- 使用`max`缓存结果，使用`array`动态储存数据
- 循环`s`长度，如果`array`中有重复数据，清空，重新计数
- 一旦`array`的长度大于`max`,赋值给`max`


## 寻找两个正序数组的中位数

- 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

- 输入：nums1 = [1,3], nums2 = [2]
- 输出：2.00000
- 解释：合并数组 = [1,2,3] ，中位数 2

```js
var findMedianSortedArrays = function (nums1, nums2) {
    let n = nums1.length + nums2.length;
    let nums = nums1.concat(nums2).sort((a, b) => a - b);

    let result = n % 2 == 0 ?
      (nums[n / 2] + nums[n / 2 - 1]) / 2 :
      nums[Math.floor(n / 2)];

    return result;
  };
```

## 最长回文子串

- 给你一个字符串 s，找到 s 中最长的回文子串。

- 输入：s = "babad"
- 输出："bab"
- 解释："aba" 同样是符合题意的答案。

```js
  var longestPalindrome = function (s) {
    if (s.length < 2) return s;

    let res = '';
    for (let i = 0; i < s.length; i++) {
      getCenter(i, i);
      getCenter(i, i + 1);
    }

    function getCenter(left, right) {
      while (left >= 0 && right < s.length && s[left] == s[right]) {
        left--;
        right++;
      }

      if (right - left - 1 > res.length) {
        res = s.slice(left + 1, right);
      } 
    }
    return res
  };
```

## Z字形变换


- 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

- 比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

- P   A   H   N
- A P L S I I G
- Y   I   R
- 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。



```js
  var convert = function (s, numRows) {
    if (s.length <= numRows || numRows === 1) {
      return s
    }
    const arr = new Array(numRows).fill('')
    let num = 0
    let plus = true
    for (let i = 0; i < s.length; i++) {
      arr[num] += s[i]

      if (plus) {
        num += 1
      } else {
        num -= 1
      }

      if (num === 0) {
        plus = true
      }
      if (num === numRows - 1) {
        plus = false
      }

    }
    return arr.join('')
  };
```

## 整数反转

- 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
- 如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
- 假设环境不允许存储 64 位整数（有符号或无符号）。

```js
 var reverse = function (x) {
    if (/^(-{0,1})(\d{1,})$/.test(x)) {
      let c = RegExp.$1;
      let n = RegExp.$2
      n = Number(n.split('').reverse().join(''))
      var limit = Math.pow(2, 31)
      if (n >= limit) {
        return 0
      } else {
        return c += n
      }
    } else {
      return '0'
    }
  }
```
